<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0034)http://e-maxx.ru/algo/segment_tree -->
<html class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>MAXimal :: algo :: Tree segments</title><meta name="author" lang="ru" content="e-maxx"><meta name="description" content="Алгоритмы, олимпиадное программирование, математика"><meta name="keywords" content="алгоритмы программирование"><link rel="stylesheet" type="text/css" href="./MAXimal __ algo __ Tree segments_files/style.css"><script type="text/javascript" src="./MAXimal __ algo __ Tree segments_files/jquery.js.download"></script><script type="text/javascript" src="./MAXimal __ algo __ Tree segments_files/page-contents.js.download"></script><link rel="stylesheet" type="text/css" href="./MAXimal __ algo __ Tree segments_files/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--><script type="text/javascript" async="" src="./MAXimal __ algo __ Tree segments_files/embed.js.download"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./MAXimal __ algo __ Tree segments_files/translateelement.css"><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.5f320136407b4b716619268fc1ad7aa5.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.32e4f6dbe55aedef6eaa93586af6fe59.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.a74156cf18b6a987243b3e8cd4909bfc.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"></head><body><div id="goog-gt-tt" class="goog-tooltip skiptranslate" dir="ltr" style="visibility: hidden; left: 596px; top: 258px; display: none;"><div style="padding: 8px;"><div><div class="logo"><img src="./MAXimal __ algo __ Tree segments_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">Дерево отрезков — это структура данных, которая позволяет эффективно (т.е. за асимптотику ) реализовать операции следующего вида: нахождение суммы/минимума элементов массива в заданном отрезке (, где  и  поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива (т.е. разрешается присвоить всем элементам  какое-либо значение, либо прибавить ко всем элементам массива какое-либо число).</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none; opacity: 0;"></div></div><table class="main" cellpadding="0" cellspacing="0"><tbody><tr><td class="title" colspan="2"><p><font><font>MAXimal</font></font></p></td></tr><tr><td class="menu"><ul><li><a href="http://e-maxx.ru/index.php"><font><font>home</font></font></a></li><li><a href="http://e-maxx.ru/algo/" class="current"><font><font>algo</font></font></a></li><li><a href="http://e-maxx.ru/bookz/"><font><font>bookz</font></font></a></li><li><a href="http://e-maxx.ru/forum/"><font><font>forum</font></font></a></li><li><a href="http://e-maxx.ru/about.php"><font><font>about</font></font></a></li></ul></td><td class="content"><p class="algoinfo"><font><font>Posted: 11 Jun 2008 11:00 </font></font><br><font><font>Edited: 25 Oct 2011 21:31</font></font></p><div id="contents-table"><p id="contents-table-title"><font><font>Contents </font></font><a href="http://e-maxx.ru/algo/segment_tree#" id="contents-hide"><font><font>[hide]</font></font></a><a href="http://e-maxx.ru/algo/segment_tree#" id="contents-show" style="display:none"><font><font>[View]</font></font></a></p><div><ul><li><a href="http://e-maxx.ru/algo/segment_tree#0"><font><font>Wood pieces</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#1"><font><font>wood Description of segments in the base case</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#2"><font><font>The tree structure segments</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#3"><font><font>building</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#4"><font><font>request amount</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#5"><font><font>update request</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#6"><font><font>implementation</font></font></a></li></ul><li><a href="http://e-maxx.ru/algo/segment_tree#7"><font><font>Complexity; version segments of wood</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#8"><font><font>More complex functions and queries</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#9"><font><font>Minimum / maximum value</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#10"><font><font>Minimum / maximum value and the number of times that it meets</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#11"><font><font>Find the greatest common divisor / least common multiple</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#12"><font><font>Counting the number of zeros, search </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/336a051837a2ed662422914225a362d0.png" alt="k"><font><font>th zero</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#13"><font><font>array prefix search with a given sum</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#14"><font><font>Search subsegment with a maximum amount</font></font></a></li></ul><li><a href="http://e-maxx.ru/algo/segment_tree#15"><font><font>Saving the entire subarray segments at each vertex of the tree</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#16"><font><font>Find the smallest number, greater than or equal to the specified value, the specified interval. </font><font>no modification requests</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#17"><font><font>Find the smallest number, greater than or equal to the specified value, the specified interval. </font><font>Allowed modification requests</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#18"><font><font>Find the smallest number, greater than or equal to the specified value, the specified interval. </font><font>The acceleration technique using a "partial cascading"</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#19"><font><font>Other possible destinations</font></font></a></li></ul><li><a href="http://e-maxx.ru/algo/segment_tree#20"><font><font>Update on the interval</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#21"><font><font>The addition of the segment</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#22"><font><font>The assignment of the segment</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#23"><font><font>Addition of the segment, the maximum request</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#24"><font><font>other destinations</font></font></a></li></ul><li><a href="http://e-maxx.ru/algo/segment_tree#25"><font><font>Generalization to higher dimensions</font></font></a></li><ul><li><a href="http://e-maxx.ru/algo/segment_tree#26"><font><font>The two-dimensional tree segments in the simplest embodiment,</font></font></a></li><li><a href="http://e-maxx.ru/algo/segment_tree#27"><font><font>Compression of two-dimensional pieces of wood</font></font></a></li></ul><li><a href="http://e-maxx.ru/algo/segment_tree#28"><font><font>Wood preserving segments of its history values &#8203;&#8203;(data to improve persistent-structure)</font></font></a></li></ul></ul></ul></div></div><a name="0"></a><h1 id="header_0"><font><font>Wood pieces</font></font></h1><p><font><font class="">Wood pieces - a data structure that allows efficient (i.e. for the asymptotic </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font class="">) to implement operations of the following form: finding the sum / minimum array elements in a predetermined interval ( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font class="">where </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"><font><font class="">and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"><font><font class="">are input to the algorithm), thus further possible to change the elements of the array: as changing the value of one element, and the change elements in general subsegments array (i.e. all elements are allowed to assign </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font class="">a value, or add to all array elements any number).</font></font></p><p><font><font>In general, the segment tree - a very flexible structure, and the number of problems solved by it is theoretically unlimited. </font><font class="">In addition to the forms shown above operations with trees segments as possible and much more complex operation (see. "Versions of complexity; wood segments" section). </font><font>In particular, the segment tree is easily generalized to higher dimensions: for example, to solve the problem of finding the amount / minimum, in a given matrix podpryamougolnike (though if only for the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\ log ^ 2 n)"><font><font>).</font></font></p><p><font><font>An important feature of the tree segments is that they consume a linear memory space: the standard tree segments required order </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3425c224e2cf3a567f27c33d26d4e256.png" alt="4n"><font><font>of memory elements for operation over array size </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>.</font></font></p><p></p><p></p><a name="1"></a><h2 style="padding-top:40px;" id="header_1"><font><font>wood Description of segments in the base case</font></font></h2><p><font><font>First, consider the simplest case of the segments of wood - wood pieces for sums. </font><font>If you set the task formally, then we have an array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61e687505738756a5a0a875e68fef95c.png" alt="a [0..n-1]"><font><font>, and our tree sections must be able to find the sum of the elements from the </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"><font><font>th to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"><font><font>th (this request amount), as well as handle the change in the value of the specified element in the array, ie, </font><font>effectively respond to the assignment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/20a786def4744c0a6d30e1718c6d970c.png" alt="a [i] = x"><font><font>(this modification request). </font><font>Once again, the segments tree should handle both the request for time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>.</font></font></p><p></p><p></p><a name="2"></a><h3 style="padding-top:15px;" id="header_2"><font><font>The tree structure segments</font></font></h3><p><font><font>So, what is a segment tree?</font></font></p><p><font><font>We calculate and remember somewhere sum of all elements of the array, ie, </font><font>segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a [0 \ ldots n-1]"><font><font>. </font><font>Also, we calculate the sum of two halves of the array: </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/956cf050b80daaa13a7143f3acb10f4e.png" alt="a [0 \ ldots n / 2]"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1edf1b374780b75661e2628028abec7d.png" alt="a [n / 2 + 1 \ ldots n-1]"><font><font>. </font><font>Each of these two halves, in turn, will divide in half, calculate and store the sum on them, then we will divide in half again, and so on until it reaches the current segment length </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"><font><font>. </font><font>In other words, we start with the segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/16dc8025ca4b7286177f4afcbe0543b5.png" alt="[0; n-1]"><font><font>and each time we divide the current segment in two (if he has not yet become a segment of unit length), then causing the same procedure on both halves; </font><font>for each such segment, we store the sum of numbers on it.</font></font></p><p><font><font>You can say that these segments in which we considered the amount, form a tree: the root of the tree - cut </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ecff96120a9209d01863bd81ef70ba4b.png" alt="[0 \ ldots n-1]"><font><font>, and each vertex has exactly two sons (except vertex-leaf, in which the segment has a length </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"><font><font>). </font><font>Hence the name - "wood pieces" (although the implementation is usually no tree is clearly not built, but more on that below in the implementation).</font></font></p><p><font><font>So, we have described the structure of the tree segments. </font><font>Now we note that it has a </font></font><b><font><font>linear dimension</font></font></b><font><font> , namely, comprises less </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/02f3339bd527ea60f4b8a5fcb94023f1.png" alt="2n"><font><font>vertices. </font><font>This can be understood as follows: the first level of the tree segments contains one node (segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ecff96120a9209d01863bd81ef70ba4b.png" alt="[0 \ ldots n-1]"><font><font>), the second layer - in the worst case, two peaks, the third level in the worst case there will be four peaks, and so on, until the number of vertices is reached </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>. </font><font>Thus, the number of vertices in the worst case estimated amount </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d35b3d070df776c04c090026321e7a7a.png" alt="n + n / 2 + n / 4 + n / 8 + \ ldots + 1 &lt;2n"><font><font>.</font></font></p><p><font><font>It should be noted that when </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>other than deuce degrees, not all segments of the tree levels are completely filled. </font><font>For example, when </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/bcda88883794933f7b1fcfe9f0ddaa2d.png" alt="n = 3"><font><font>the left son of the root is a segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5303948ccba946cdef40e33f43cdda9e.png" alt="[0 \ ldots 1]"><font><font>having two children, while the right son of the root - the segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/dba180d54564a30ed5dfccdcacf84606.png" alt="[2 \ ldots 2]"><font><font>being sheet. </font><font>No special difficulties in the implementation of it is not, but nevertheless it should be borne in mind.</font></font></p><p><b><font><font>The height of</font></font></b><font><font> the segments the tree is a value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>- for example, because the length of the segment tree is the root </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>and the transition down one level segments length is reduced by about half.</font></font></p><p></p><p></p><a name="3"></a><h3 style="padding-top:15px;" id="header_3"><font><font>building</font></font></h3><p><font><font>The process of constructing a tree segments for a given array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"><font><font>can be made effectively follows upwards: first write element values </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>in the corresponding leaves of the tree, then on the basis of these count values for the vertices of the previous level as the sum of the two leaves, then similarly calculate values for another level, etc. </font><font>Convenient to describe this operation recursively: we are launching the procedure for constructing the tree root segments, and the construction of the procedure itself, if it is caused not by a sheet calls itself from each of the two sons and sums the calculated values, and if it is caused by the sheet - it simply writes themselves value of the array element.</font></font></p><p><font><font>Asymptotics tree construction segments will be so </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O (n)"><font><font>.</font></font></p><p></p><p></p><a name="4"></a><h3 style="padding-top:15px;" id="header_4"><font><font>request amount</font></font></h3><p><font><font>Let us now consider the amount of the request. </font><font>Is input two numbers </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"><font><font>, and we have for the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>to calculate the sum of the numbers on the interval </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font>.</font></font></p><p><font><font>To do this, we will go down the tree building segments using to calculate the answer previously counted amounts on each node of the tree. </font><font>Initially, we get up to the root of the tree segments. </font><font>Let's see in which of his two sons query interval falls </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/653023af1da32cf3f51fe321fa0778da.png" alt="[L \ ldots r]"><font><font>(recall that the root segments sons - it stretches </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/6e1128658239f9f68b765b0e3a3d1a6a.png" alt="[0 \ ldots n / 2]"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/286bab85398b9a2f7b1db9777b827da8.png" alt="[N / 2 + 1 \ ldots n-1]"><font><font>). </font><font>There are two possibilities: that the segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/653023af1da32cf3f51fe321fa0778da.png" alt="[L \ ldots r]"><font><font>gets only one son of the root, and that, on the contrary, the segment intersects with two sons.</font></font></p><p><font><font>The first case is simple: just move on in order, in whom lies our segment query and apply the algorithm described here to the current node.</font></font></p><p><font><font>In the second case, we can not remain other choice but to go first to the left child and find the answer to a query in it, and then - go to the right child, find in it the answer and add it to our account. </font><font>In other words, if the left son represented the segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e23c36b14689e5d2b805681a2bc9d9fe.png" alt="[L_1 \ ldots r_1]"><font><font>, and the right - the segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/192b10a94c69a38d31863be3b0aa178a.png" alt="[L_2 \ ldots r_2]"><font><font>(note that </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f4ff8bd23d311e004e920ae4a02de42c.png" alt="l_2 = r_1 + 1"><font><font>), we move on to the leftmost child of the request </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/79631314998919abe7a50cc5546efdc7.png" alt="[L \ ldots r_1]"><font><font>, and the right - with the request </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/b6985a36468a0de79c5847d25c3aed69.png" alt="[L_2 \ ldots r]"><font><font>.</font></font></p><p><font><font>Thus, the amount of processing of the request is a </font></font><b><font><font>recursive function</font></font></b><font><font> that calls itself whenever either of the left son, or from the right (without changing the boundaries of the query in both cases), or on both at once (at the same time sharing our inquiry into two corresponding subquery). </font><font>However, recursive calls we do not always: if the current request coincided with the boundaries of the segment in the current top of the tree segments, the response will return a precalculated value amounts on this segment recorded in tree segments.</font></font></p><p><font><font>In other words, the query calculation is a descent of the tree segments, which applies to all branches of the tree fit, and for fast work has been used for calculating the sum of each segment in the tree segments.</font></font></p><p><font><font>Why is </font></font><b><font><font>the asymptotic behavior</font></font></b><font><font> of this algorithm will be </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>? </font><font>To do this, look at each level of the tree segments as maximum lengths can visit our recursive function in the processing of a request. </font><font>It is argued that such segments could not be more than four; </font><font>whereas, given the estimate </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>for the height of the tree, we obtain the required asymptotic behavior of the running time.</font></font></p><p><font><font>We show that this assessment of the four segments is correct. </font><font>In fact, at the zero level of the tree query affected only the tip - the root of the tree. </font><font>Further to the first level of the recursive call in the worst case is divided into two recursive calls, but it is important here is that the requests in these two challenges will coexist, ie </font><font>number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/b8eb666582c568931fab689087c4420f.png" alt="l ^ {\ prime \ prime}"><font><font>request in the second recursive call is one more than the number of </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/78314c9c457a2b2226b69c669bca9805.png" alt="r ^ \ prime"><font><font>request in the first recursive call. </font><font>It follows that at the next level, each of these two challenges could produce more two recursive call, but in this case, half of the non-recursive queries will work, taking the required value from the top segments of the tree. </font><font>Thus, every time we will have no more than two real working recursion branches (we can say that one branch is closer to the left border of the request, and the second branch - to the right), and the total number of affected segments may not exceed the height of the tree lengths, multiplied by the four, ie, </font><font>it is a number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>.</font></font></p><p><font><font>Finally, you can lead such an understanding of the amount of work request: input segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/653023af1da32cf3f51fe321fa0778da.png" alt="[L \ ldots r]"><font><font>is divided into several subsegments, the answer to each of which are already calculated and stored in the tree. </font><font>If you do it the right way partition, thanks to the tree structure of the segments of the number of subsegments will always be necessary </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>, and that gives the efficiency of the wood pieces.</font></font></p><p></p><p></p><a name="5"></a><h3 style="padding-top:15px;" id="header_5"><font><font>update request</font></font></h3><p><font><font>Recall that the update request takes an index </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>and a value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>, and rebuilds the index tree so that it corresponds to the new value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/20a786def4744c0a6d30e1718c6d970c.png" alt="a [i] = x"><font><font>. </font><font>This request must also be carried out during the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>.</font></font></p><p><font><font>This is more than a simple request for requesting the amount of calculation. </font><font>The fact that the item </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>involves only a relatively small number of vertices of the tree segments: namely, in the </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>top - one on each level.</font></font></p><p><font><font>Then it is clear that the update request can be implemented as a recursive function: it is passed to the current vertex sections of the tree, and this function performs a recursive call from one of his two sons (of which contains the position </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>in its segment), and then - recalculates the value of the sum in the current node in the same way as we have done in the construction of wood segments (ie, the sum of the values of the two sons of the current node).</font></font></p><p></p><p></p><a name="6"></a><h3 style="padding-top:15px;" id="header_6"><font><font>implementation</font></font></h3><p><font><font>The main follow- up time - is how </font></font><b><font><font>to store</font></font></b><font><font> the tree segments in memory. </font><font>For the purpose of simplicity, we will not store the tree explicitly, and use this trick: let's say that the root of the tree has a number of </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"><font><font>his sons - the numbers </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0e96f2a3dff7da2f31d78c5306207a14.png" alt="3"><font><font>their sons - rooms with </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/540ccd7efd169a4313503b565bb0ce55.png" alt="4"><font><font>on </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5c705587512261d7061e23ba54f595f3.png" alt="7"><font><font>and so forth. </font><font>It is easy to understand the correctness of the following formula: if the node is number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>, then let her son left - is the pinnacle of a number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/59208d781cf256429eabcdaf6a812a0f.png" alt="2i"><font><font>, and the right - with the number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5bfad4c5b8e0ccbdeacca62dc6e71531.png" alt="2i + 1"><font><font>.</font></font></p><p><font><font>This technique greatly simplifies the programming of pieces of wood - now we do not need to be stored in the memory tree structure segments, and only make any array for sums on each segment of the tree segments.</font></font></p><p><font><font>One has only to note that the size of the array in such a numbering is not necessary to put </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/02f3339bd527ea60f4b8a5fcb94023f1.png" alt="2n"><font><font>as well </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3425c224e2cf3a567f27c33d26d4e256.png" alt="4n"><font><font>. </font><font>The fact that such a numbering is not working perfectly when </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>not a power of two - then there are the missing numbers that do not match any top of the tree (actually numbering behaves just as if it </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>would be rounded up to the nearest power of two) . </font><font>It does not create any difficulties in the implementation, however, it leads to the fact that the size of the array should be increased to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3425c224e2cf3a567f27c33d26d4e256.png" alt="4n"><font><font>.</font></font></p><p><font><font>Thus, the segment tree, we </font></font><b><font><font>keep</font></font></b><font><font> just as an array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ef81dd9a1c266209451a0f924cf42f69.png" alt="t []"><font><font>, the size of four times the size </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>of the input data:</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">int</span> n, t<span class="br0">[</span><span class="nu0">4</span><span class="sy2">*</span>MAXN<span class="br0">]</span><span class="sy4">;</span></pre><p><font><font>The procedure for </font></font><b><font><font>construction of sections of the tree</font></font></b><font><font> for a given array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font><font>is as follows: it is a recursive function, it is passed to the array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font><font>, the number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/9530057de1d317139fef00be858ff2f1.png" alt="v"><font><font>of the current top of the tree, and the boundaries </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5ae6342347ce16806929411d1b038186.png" alt="tl"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/228f216330bd322361137b12344e6ec5.png" alt="tr"><font><font>segment corresponding to the current top of the tree. </font><font>From the main program to call this function should be the parameters </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3503963bbad8d7409534664fa753ebe5.png" alt="v = 1"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/7c1d976ea14775e1e40a39f002657d59.png" alt="tl = 0"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c95d88cd10b654cc16ca3eeedb327f64.png" alt="tr = n-1"><font><font>.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> build <span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> a<span class="br0">[</span>tl<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">)</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">+</span> t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>Further, the function of </font></font><b><font><font>the amount of the request</font></font></b><font><font> is a also a recursive function in the same way that the information is transferred to the current top of the tree (ie, number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/9530057de1d317139fef00be858ff2f1.png" alt="v"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5ae6342347ce16806929411d1b038186.png" alt="tl"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/228f216330bd322361137b12344e6ec5.png" alt="tr"><font><font>which in the main program must pass values </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0409310e642143903bd490e71e4a951e.png" alt="n-1"><font><font>respectively), and in addition to this - also border </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"><font><font>the current request. </font><font>In order to simplify this code fukntsii always makes two recursive calls, even if actually need one - just extra recursive call will be transferred request, which </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f923f209dbbbf1e2adcce5d2eb545ef1.png" alt="l&gt; r"><font><font>it is easy to cut off an additional check at the beginning of the function.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">int</span> sum <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> r<span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> r <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> sum <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">(</span>r,<span class="kw4">tm</span><span class="br0">)</span><span class="br0">)</span>
		<span class="sy2">+</span> sum <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">(</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, r<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>Finally, the </font></font><b><font><font>modification request</font></font></b><font><font> . </font><font>He just passed information about the current top of the tree lines, and additionally, the index changing element, as well as its new value.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> update <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> new_val<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">+</span> t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>It is worth noting that the feature </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/77d78f9a8de6ca2b7cee5167b9d428b6.png" alt="\ Rm update"><font><font>is easy to make a non-recursive, because her tail recursion, ie </font><font>branches never happens: one call can generate only one recursive call. </font><font>When non-recursive implementation of the speed can increase by several times.</font></font></p><p><font><font>Other </font></font><b><font><font>optimizations</font></font></b><font><font> it is worth mentioning that the multiplication and division by two is necessary to replace bit operations - is also slightly improves the performance of the segments of the tree.</font></font></p><p></p><p></p><a name="7"></a><h2 style="padding-top:40px;" id="header_7"><font><font>Complexity; version segments of wood</font></font></h2><p><font><font>Wood pieces - a very flexible structure, and allows you to make generalizations in many different directions. </font><font>Let us try to classify them below.</font></font></p><p></p><p></p><a name="8"></a><h3 style="padding-top:15px;" id="header_8"><font><font>More complex functions and queries</font></font></h3><p><font><font>Improvements pieces of wood in this area can be a fairly obvious (as in the case of a minimum / maximum amount instead) and very, very non-trivial.</font></font></p><p></p><a name="9"></a><h4 id="header_9"><font><font>Minimum / maximum value</font></font></h4><p><font><font>Slightly modify the condition of the problem described above: instead of the amount of the request will produce query now minimum / maximum on the segment.</font></font></p><p><font><font>Then the tree lengths to do this practically does not differ from the wood segments described above. </font><font>Just need to change the method of calculating </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/984b49d9311673e2bd809524d195f995.png" alt="t [v]"><font><font>in functions </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/de937760ef15f987c930d6f7eb8ef330.png" alt="\ Rm build"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/77d78f9a8de6ca2b7cee5167b9d428b6.png" alt="\ Rm update"><font><font>, as well as the calculation of the return response function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/93bc2a33a44683e63c7f8118b9c2ced4.png" alt="\ Rm sum"><font><font>(replace the summation in the minimum / maximum).</font></font></p><p></p><a name="10"></a><h4 id="header_10"><font><font>Minimum / maximum value and the number of times that it meets</font></font></h4><p><font><font>The task is similar to the previous one, but now in addition to the maximum amount required to also return its occurrences. </font><font>This problem arises in a natural way, for example, at the decision of using wood pieces such task: to find the number of the longest increasing subsequence in a given array.</font></font></p><p><font><font>To solve this problem at each node of the tree segments will store a pair of numbers: in addition to the maximum number of its occurrences in the corresponding interval. </font><font>Then the construction of the tree we have just two such pairs obtained from the sons of the current top, get a pair for the current top.</font></font></p><p><font><font>Combining two such pairs one should be a separate function because this operation will have to produce and to modify the query, and the query maximum search.</font></font></p><p></p><pre class="notranslate cpp">pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> t<span class="br0">[</span><span class="nu0">4</span><span class="sy2">*</span>MAXN<span class="br0">]</span><span class="sy4">;</span>
&nbsp;
pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> combine <span class="br0">(</span>pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> a, pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> b<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>a.<span class="me1">first</span> <span class="sy1">&gt;</span> b.<span class="me1">first</span><span class="br0">)</span>
		<span class="kw1">return</span> a<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>b.<span class="me1">first</span> <span class="sy1">&gt;</span> a.<span class="me1">first</span><span class="br0">)</span>
		<span class="kw1">return</span> b<span class="sy4">;</span>
	<span class="kw1">return</span> make_pair <span class="br0">(</span>a.<span class="me1">first</span>, a.<span class="me1">second</span> <span class="sy2">+</span> b.<span class="me1">second</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> build <span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> make_pair <span class="br0">(</span>a<span class="br0">[</span>tl<span class="br0">]</span>, <span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">)</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> combine <span class="br0">(</span>t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> get_max <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> r<span class="br0">)</span>
		<span class="kw1">return</span> make_pair <span class="br0">(</span><span class="sy2">-</span>INF, <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> r <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> combine <span class="br0">(</span>
		get_max <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">(</span>r,<span class="kw4">tm</span><span class="br0">)</span><span class="br0">)</span>,
		get_max <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">(</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, r<span class="br0">)</span>
	<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> make_pair <span class="br0">(</span>new_val, <span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> combine <span class="br0">(</span>t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p></p><a name="11"></a><h4 id="header_11"><font><font>Find the greatest common divisor / least common multiple</font></font></h4><p><font><font>Those. </font><font>we want to learn to look for GCD / NOC of all the numbers in a given array segment.</font></font></p><p><font><font>It's pretty interesting generalization pieces of wood obtained in exactly the same way as the trees stretches to the amount / minimum / maximum: simply stored in each node of the tree NOD / NOC of all the numbers in the appropriate segment of the array.</font></font></p><p></p><a name="12"></a><h4 id="header_12"><font><font>Counting the number of zeros, search </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/336a051837a2ed662422914225a362d0.png" alt="k"><font><font>th zero</font></font></h4><p><font><font>In this problem, we want to learn how to respond to the number of zeros in the array given interval request and the request of finding </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>th element zero.</font></font></p><p><font><font>Again slightly modify the data stored in the tree segments: Now we will store in the array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ef81dd9a1c266209451a0f924cf42f69.png" alt="t []"><font><font>number of zeros occurring in their respective segments of the array. </font><font>It is clear how to maintain and use the data in the functions </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/de937760ef15f987c930d6f7eb8ef330.png" alt="\ Rm build"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/93bc2a33a44683e63c7f8118b9c2ced4.png" alt="\ Rm sum"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/77d78f9a8de6ca2b7cee5167b9d428b6.png" alt="\ Rm update"><font><font>, - thus we have solved the problem of the number of zeros in a given array segment.</font></font></p><p><font><font>Now we learn how to solve the problem of finding the position of </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>the ith entry in the array zero. </font><font>To do this, we will go down the tree lines, starting at the root and moving each time to the left or right child, depending on which of the sections is desired </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>th zero. </font><font>In fact, to understand what the son we have to move on, just look at the value recorded in the left son: if it is greater than or equal to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>, the transition should be to the left son (because of its segment has at least </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>zero) and otherwise - to move in the right child.</font></font></p><p><font><font>When implementation is to cut the case when </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>-th zero does not exist, even when entering a function returned as a response, for example </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1"><font><font>.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">int</span> find_kth <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> k<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>k <span class="sy1">&gt;</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> tl<span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">&gt;=</span> k<span class="br0">)</span>
		<span class="kw1">return</span> find_kth <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, k<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> find_kth <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, k <span class="sy2">-</span> t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p></p><a name="13"></a><h4 id="header_13"><font><font>array prefix search with a given sum</font></font></h4><p><font><font>The task such: it is required for a given value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>quickly find such </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>that the sum of the first </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"><font><font>element of the array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font><font>is greater than or equal to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>(assuming that the array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font><font>contains only non-negative integers).</font></font></p><p><font><font>This problem can be solved by a binary search, calculating each time inside amount for a particular prefix array, but it will lead to the solution of the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\ log ^ 2 n)"><font><font>.</font></font></p><p><font><font>Instead, you can use the same idea as in the previous paragraph, and look for the desired position of a descent on a tree, moving each time to the left or right child, depending on the value of the sum in the left son. </font><font>Then the response to the search request would be one such descent of the tree, and therefore, will be carried over </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>.</font></font></p><p></p><a name="14"></a><h4 id="header_14"><font><font>Search subsegment with a maximum amount</font></font></h4><p><font><font>As before, the input is given to the array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a [0 \ ldots n-1]"><font><font>, and receives requests </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5da5090de09ee020bba6974c7d377e42.png" alt="(L, r)"><font><font>, which means: to find a subsegment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/faa9743f8b52e0bf987f66f0f3748822.png" alt="a [l ^ \ prime \ ldots r ^ \ prime]"><font><font>that </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/90c5d4529cb50b2ef4b5730893a2db01.png" alt="l \ le l ^ \ prime"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/7d217c79dc2e25e44c5719338e91b173.png" alt="r ^ \ prime \ le r"><font><font>and the sum of the length of </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/faa9743f8b52e0bf987f66f0f3748822.png" alt="a [l ^ \ prime \ ldots r ^ \ prime]"><font><font>the maximum. </font><font>Request for modification of individual elements of the array are allowed. </font><font>The array elements can be negative (and, for example, if all the numbers are negative, the best subsegments will be empty - on it the amount is zero).</font></font></p><p><font><font>This is a very non-trivial generalization pieces of wood obtained as follows. </font><font>Will be stored in each node of the tree segments four values: the amount on this segment, the maximum amount of all the prefixes of this segment, the maximum amount of all suffixes, as well as the maximum amount subsegment on it. </font><font>In other words, for each piece of wood pieces response to it has predposchitan, as well as an additional response is counted among all segments, resting on the left section of the border, as well as among all sections, resting on the right border.</font></font></p><p><font><font>How do you build a tree with segments such data? </font><font>Again, we get to it with a recursive point of view: to let the current top four values &#8203;&#8203;in the left son and son in law had already counted, count them now for the summit. </font><font>Note that the answer is in the very top:</font></font></p><p></p><ul><li><font><font>or answer in the left son, which means that the best subsegment in the current top of the whole is placed in a section of the left son,</font></font></li><li><font><font>or answer in the right son, which means that the best subsegment in the current top of the whole is placed in the right section of the son,</font></font></li><li><font><font class="">either the maximum amount of the suffix in the left son and the maximum prefix in the right son, which means that the best subsegment is its beginning in the left son, and the end - to the right.</font></font></li></ul><p><font><font>Hence, in response to the current vertex is the maximum of these three values. </font><font>Recalculate the maximum amount for the prefix and suffix is even easier. </font><font>We present the implementation of a function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8acda8e6df059bc22646e01009cd6546.png" alt="\ Rm combine"><font><font>that, given two structures </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/9830bd111d20d5d83caa873af1cecd6c.png" alt="\ Rm data"><font><font>, containing the data on the left and right sons, and that returns data in the current top.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">struct</span> data <span class="br0">{</span>
	<span class="kw4">int</span> sum, pref, suff, ans<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
data combine <span class="br0">(</span>data l, data r<span class="br0">)</span> <span class="br0">{</span>
	data res<span class="sy4">;</span>
	res.<span class="me1">sum</span> <span class="sy1">=</span> l.<span class="me1">sum</span> <span class="sy2">+</span> r.<span class="me1">sum</span><span class="sy4">;</span>
	res.<span class="me1">pref</span> <span class="sy1">=</span> max <span class="br0">(</span>l.<span class="me1">pref</span>, l.<span class="me1">sum</span> <span class="sy2">+</span> r.<span class="me1">pref</span><span class="br0">)</span><span class="sy4">;</span>
	res.<span class="me1">suff</span> <span class="sy1">=</span> max <span class="br0">(</span>r.<span class="me1">suff</span>, r.<span class="me1">sum</span> <span class="sy2">+</span> l.<span class="me1">suff</span><span class="br0">)</span><span class="sy4">;</span>
	res.<span class="me1">ans</span> <span class="sy1">=</span> max <span class="br0">(</span>max <span class="br0">(</span>l.<span class="me1">ans</span>, r.<span class="me1">ans</span><span class="br0">)</span>, l.<span class="me1">suff</span> <span class="sy2">+</span> r.<span class="me1">pref</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>Thus, we learned how to build a tree segments. </font><font>Hence it is easy to get and the implementation of the modification request: as in the simplest segments tree, we do Central values in all segments of the tree tops changed, for which we use all the same function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8acda8e6df059bc22646e01009cd6546.png" alt="\ Rm combine"><font><font>. </font><font>To calculate the values in the tree leaves as an auxiliary function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/625800dc6e651d2b6823a01fe11ad93d.png" alt="\ Rm make \ _data"><font><font>which returns a structure </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/9830bd111d20d5d83caa873af1cecd6c.png" alt="\ Rm data"><font><font>, the calculated one number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/bb7de26cb5f36ac3575b89190db5c8c0.png" alt="\ Rm val"><font><font>.</font></font></p><p></p><pre class="notranslate cpp">data make_data <span class="br0">(</span><span class="kw4">int</span> val<span class="br0">)</span> <span class="br0">{</span>
	data res<span class="sy4">;</span>
	res.<span class="me1">sum</span> <span class="sy1">=</span> val<span class="sy4">;</span>
	res.<span class="me1">pref</span> <span class="sy1">=</span> res.<span class="me1">suff</span> <span class="sy1">=</span> res.<span class="me1">ans</span> <span class="sy1">=</span> max <span class="br0">(</span><span class="nu0">0</span>, val<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> build <span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> make_data <span class="br0">(</span>a<span class="br0">[</span>tl<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">)</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> combine <span class="br0">(</span>t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> make_data <span class="br0">(</span>new_val<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> combine <span class="br0">(</span>t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>Necessary to understand the query response. </font><font>To do this, we also, as before, we get down on wood, breaking thus the segment query </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/653023af1da32cf3f51fe321fa0778da.png" alt="[L \ ldots r]"><font><font>into several subsegments, coinciding with wood segments segments, and merge the answers to them in a single answer to the whole problem. </font><font>Then it is clear that the work is no different from ordinary wood work pieces, but instead should be a simple addition / minimum / maximum values to use the function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8acda8e6df059bc22646e01009cd6546.png" alt="\ Rm combine"><font><font>. </font><font>The below implementation is a bit different from the implementation of a query </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/93bc2a33a44683e63c7f8118b9c2ced4.png" alt="\ Rm sum"><font><font>: it does not allow for cases where the left boundary of </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"><font><font>the query is greater than the right border </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"><font><font>(otherwise any unpleasant incidents - what structure </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/9830bd111d20d5d83caa873af1cecd6c.png" alt="\ Rm data"><font><font>I return when the query interval empty ..?).</font></font></p><p></p><pre class="notranslate cpp">data query <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>r <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
		<span class="kw1">return</span> query <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, r<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> <span class="kw4">tm</span><span class="br0">)</span>
		<span class="kw1">return</span> query <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, l, r<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">return</span> combine <span class="br0">(</span>
		query <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, <span class="kw4">tm</span><span class="br0">)</span>,
		query <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, r<span class="br0">)</span>
	<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p></p><p></p><a name="15"></a><h3 style="padding-top:15px;" id="header_15"><font><font>Saving the entire subarray segments at each vertex of the tree</font></font></h3><p><font><font>This is a separate subsection, standing apart from the rest, because at each node of the tree segments, we will not keep some concise information on this subsegments (sum, minimum, maximum, etc.), and </font></font><b><font><font>all the</font></font></b><font><font> elements of an array lying in the subsegments. </font><font>Thus, the root of the tree segments will store all elements of the array, the left son of the root - the first half of the array, the right son of the root - the second half, and so on.</font></font></p><p><font><font>The simplest version of the application of this technique - when stored sorted list of all the numbers in each node of the tree segments occurring in the corresponding interval. </font><font>In more complex embodiments not stored lists, and any data structures built on these lists ( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/69ee37dcc56b08d150f58c59e467f874.png" alt="\ Rm set"><font><font>, </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2914117bd9c3f88c889641b5ed7e2461.png" alt="\ Rm map"><font><font>etc.). </font><font>But all these methods have in common that in each node of the tree segments stored some data structure in memory having a size of about length of the corresponding segment.</font></font></p><p><font><font>The first natural question facing when considering trees segments of this class - this is </font></font><b><font><font>the amount of memory consumed</font></font></b><font><font> . </font><font>It is argued that if each node of the tree contains a list of all segments found on this segment of numbers, or any other of the same order of size of the data structure, the sum of all segments of the tree will take up </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \ log n)"><font><font>memory cells. </font><font>Why is this so? </font><font>Because each number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>falls to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>pieces of wood pieces (at least so that the height of the tree segments have </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>).</font></font></p><p><font><font>Thus, despite the apparent extravagance of the segments of the wood it consumes memory is not much more than ordinary wood segments.</font></font></p><p><font><font>The following describes a few typical applications of such a data structure. </font><font>It should be noted immediately clear analogy trees segments of this type with </font></font><b><font><font>two-dimensional data structures</font></font></b><font><font> (in fact, in a sense, this is a two-dimensional data structure, but with a rather limited possibilities).</font></font></p><p></p><a name="16"></a><h4 id="header_16"><font><font>Find the smallest number, greater than or equal to the specified value, the specified interval. </font><font>no modification requests</font></font></h4><p><font><font>Required to respond to requests from the following: </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2299c7cb2af1f2f4088808efbc21bf69.png" alt="(L, r, x)"><font><font>that means finding the minimum number in the interval </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font>that is greater than or equal to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>.</font></font></p><p><b><font><font>We construct the</font></font></b><font><font> segment tree, in which each node will store the sorted list of all the numbers appearing on the corresponding interval. </font><font>For example, the root will contain an array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a []"><font><font>in sorted order. </font><font>How to build a tree of segments as efficiently as possible? </font><font>To do this, we are approaching the problem, as usual, in terms of recursion: if the left and right sons of the current top these lists have already been built, and we need to build this list for the current node. </font><font>In this formulation, the question becomes almost obvious that this can be done in linear time: we just need to merge two sorted lists into one that is done in one pass on them with two pointers. </font><font>C ++ users even easier, because the merging algorithm is already included in the standard STL library:</font></font></p><p></p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> t<span class="br0">[</span><span class="nu0">4</span><span class="sy2">*</span>MAXN<span class="br0">]</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> build <span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">(</span><span class="nu0">1</span>, a<span class="br0">[</span>tl<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">)</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">)</span><span class="sy4">;</span>
		merge <span class="br0">(</span>t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>,
			back_inserter <span class="br0">(</span>t<span class="br0">[</span>v<span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre><p><font><font>We already know that the segments constructed in such a way the tree will take up </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \ log n)"><font><font>memory. </font><font>And with such an implementation time of its construction also has value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \ log n)"><font><font>- because every list is constructed in linear time with respect to its size. </font><font>(Speaking of which, here there is an obvious analogy with the algorithm </font></font><b><font><font>merge sort</font></font></b><font><font> : but here we store information on all stages of the algorithm, not just the result.)</font></font></p><p><font><font>Now consider the </font></font><b><font><font>response to the request</font></font></b><font><font> . </font><font>Let's go down the tree, as does the standard answer to the inquiry in the segments tree, breaking our cut </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font>into several subsegments (order </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>items). </font><font>It is clear that the answer to the whole problem is minimized among the responses to each of the subsegments. </font><font>Now we will understand how to respond to a request for such subsegments one coinciding with a vertex of the tree.</font></font></p><p><font><font>So, we came to some top pieces of wood and want to find the answer to it, ie, </font><font>find the smallest number greater than or equal to this </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>. </font><font>To do this we just need to perform a </font></font><b><font><font>binary search</font></font></b><font><font> on the list, count on this top of the tree and return the first number on the list, is greater than or equal to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>.</font></font></p><p><font><font>Thus, the answer to the inquiry in the same subsegments occurs </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>, and the entire query is processed in the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\ log ^ 2 n)"><font><font>.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">int</span> query <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> x<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> r<span class="br0">)</span>
		<span class="kw1">return</span> INF<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">)</span> <span class="br0">{</span>
		vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> pos <span class="sy1">=</span> lower_bound <span class="br0">(</span>t<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, t<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, x<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy3">!</span><span class="sy1">=</span> t<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
			<span class="kw1">return</span> <span class="sy2">*</span>pos<span class="sy4">;</span>
		<span class="kw1">return</span> INF<span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> min <span class="br0">(</span>
		query <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">(</span>r,<span class="kw4">tm</span><span class="br0">)</span>, x<span class="br0">)</span>,
		query <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">(</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, r, x<span class="br0">)</span>
	<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>Constant </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/a7edbf6ce4bf393cf5db4311b9f2d11c.png" alt="\ Rm INF"><font><font>is some large number, certainly greater than any number in the array. </font><font>It carries the meaning of "response in a given segment does not exist."</font></font></p><p></p><a name="17"></a><h4 id="header_17"><font><font>Find the smallest number, greater than or equal to the specified value, the specified interval. </font><font>Allowed modification requests</font></font></h4><p><font><font>The task is similar to the previous one, but now resolved modification requests: to handle the assignment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/7353f11d35dc517eab4a2cb55fa502f3.png" alt="a [i] = y"><font><font>.</font></font></p><p><font><font>The solution is also similar to the solution of the previous problem, but instead of simple lists in each node of the tree segments, we will keep a balanced list, which allows you to quickly search for the desired number, delete it and insert a new number. </font><font>Given that the general number in the input array may be repeated, the best choice is the STL data structure </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/837e3e64817a11afc8df22006c713a4c.png" alt="\ Rm multiset"><font><font>.</font></font></p><p><b><font><font>Construction of</font></font></b><font><font> segments of the tree takes place about the same as in the previous problem, but now we must unite not sorted lists, and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/837e3e64817a11afc8df22006c713a4c.png" alt="\ Rm multiset"><font><font>that will lead to the fact that the asymptotic behavior of building deteriorate to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/0099e97e473671511b813930b9a76fdf.png" alt="n \ log ^ 2 n"><font><font>(although, apparently, red-black trees allow to merge the two trees in linear time, but the STL does not guarantee).</font></font></p><p><font><font>Response to </font></font><b><font><font>a search request</font></font></b><font><font> has practically equivalent to the code already stated above, except that now </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ef06ba88ff5e8e3e5acd0d038b89f321.png" alt="\ Rm lower \ _bound"><font><font>it is necessary to call up </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/984b49d9311673e2bd809524d195f995.png" alt="t [v]"><font><font>.</font></font></p><p><font><font>Finally, the </font></font><b><font><font>modification request</font></font></b><font><font> . </font><font>To handle it, we have to go down the tree by making changes to all </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>lists containing affect a component. </font><font>We simply remove the old value of the item (not forgetting that we do not need to remove them all together with the number of repetitions of this) and insert the new value.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> update <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	t<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">erase</span> <span class="br0">(</span>t<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">find</span> <span class="br0">(</span>a<span class="br0">[</span>pos<span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
	t<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">insert</span> <span class="br0">(</span>new_val<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy3">!</span><span class="sy1">=</span> tr<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
		a<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy1">=</span> new_val<span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>Processing this request also takes place during the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\ log ^ 2 n)"><font><font>.</font></font></p><p></p><a name="18"></a><h4 id="header_18"><font><font>Find the smallest number, greater than or equal to the specified value, the specified interval. </font><font>The acceleration technique using a "partial cascading"</font></font></h4><p><font><font>Improve the time response to a search request to time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>by applying techniques </font></font><b><font><font>"partial cascading"</font></font></b><font><font> ( "fractional cascading").</font></font></p><p><font><font>Partial cascading - this is a simple technique that can improve the operation of several binary searches being conducted on the same value. </font><font>In fact, the response to the search request is that we divide our task into several subtasks, each of which is then solved by the number of binary search </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>. </font><font>Partial cascading allows to replace all the binary search for one.</font></font></p><p><font><font>The simplest and most obvious example is the partial cascading </font></font><b><font><font>following problem</font></font></b><font><font> : there are several sorted lists of numbers, and we have in each list to find the first number is greater than or equal to the specified value.</font></font></p><p><font><font>If we solved the problem "head-on", it would have had to run binary search on each of those lists, if these lists are many, it becomes a very important factor: if the entire list </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>, the asymptotic behavior happens </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/36305a4c5be51fe8537b1e3b15a34838.png" alt="O (k \ log (n / k))"><font><font>where </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>- the total size of all the lists ( asymptotic behavior is because the worst case - when all lists are approximately equal to each other in length, ie equal </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/67a0b3e3294957583af82f1450f16a88.png" alt="n / k"><font><font>).</font></font></p><p><font><font>Instead, we could combine all of these lists into one sorted list in which each number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/015908c458a90fd729e3b6a927029ce1.png" alt="n_i"><font><font>will keep a list of the positions: the position in the first list of the first number is greater than or equal to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/015908c458a90fd729e3b6a927029ce1.png" alt="n_i"><font><font>a similar position in the second list, and so on. </font><font>In other words, for every number we keep occurring at the same time the number of binary search on it in each of the lists. </font><font>In this case, the asymptotic behavior of the response to the request is received </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/442fa4917638c096d0a18727a9e67395.png" alt="O (\ log n + k)"><font><font>, it is much better, but we are forced to pay a large memory consumption: namely, we need </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/45ac05c1a1331c87b1df10a93e50cbe7.png" alt="O (nk)"><font><font>memories.</font></font></p><p><font><font>Equipment partial cascading goes further in this task and achieves the memory consumption </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"><font><font>at the same time respond to the request </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/442fa4917638c096d0a18727a9e67395.png" alt="O (\ log n + k)"><font><font>. </font><font>(To do this, we do not store a large list of lengths </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>, and come back to the </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/252410059470b019db6fd4c3b844a348.png" alt="k"><font><font>list, but with each list contains every other element from the following list, we again have with each number to record its position in both lists (current and next), but it will continue to respond effectively to the request: we do a binary search on the first list, and then go to these lists in order, moving each time in the following list to help predposchitannyh pointers, and making one step to the left, considering thus that half chi </font><font>sat next list was not taken into account).</font></font></p><p><font><font>But we in our application to the wood pieces </font></font><b><font><font>do not need</font></font></b><font><font> the full power of this technique. </font><font>The fact that the list of the current top contains all the numbers that can occur in the left and right sons. </font><font>Therefore, to avoid a binary search through the list of his son, it is sufficient for each list in the segments tree count for each of its positions in the list of left and right sons (more precisely, the position of the first number is less than or equal to the current).</font></font></p><p><font><font>Thus, instead of the usual list of all the numbers we keep a list of triples: the number itself, the position in the list of the left son, the position in the list of the right son. </font><font>This will allow us for </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d0ea0c0a39869a72fadf80b704c58fbf.png" alt="O (1)"><font><font>to determine the position in the list left or right son, instead of doing a binary list on it.</font></font></p><p><font><font>The easiest way to apply this technique to the problem when the modification request is absent - then these positions are just numbers, and counting them in the construction of the tree very easily inside the algorithm merge two sorted sequences.</font></font></p><p><font><font>In the event that allowed modification requests, everything is somewhat more complicated: these positions are now to be stored in the form of iterators inside </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/837e3e64817a11afc8df22006c713a4c.png" alt="\ Rm multiset"><font><font>, and when you request an update - the right to decrease / increase for those items for which it is required.</font></font></p><p><font><font>Either way, the task has been reduced to net realizable subtleties, but the main idea - replacing </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>binary search a binary search through the list at the root of the tree - is described completely.</font></font></p><p></p><a name="19"></a><h4 id="header_19"><font><font>Other possible destinations</font></font></h4><p><font><font>Note that this technique implies a whole class of possible applications - all determined by the structure of the data selected for storage at each node of the tree. </font><font>Applications have been reviewed using the above </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/34f8b10596e5ad6a9b0d89adee5103d1.png" alt="\ Rm vector"><font><font>and </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/837e3e64817a11afc8df22006c713a4c.png" alt="\ Rm multiset"><font><font>, while generally used may be any other compact data structure: another tree lengths (more on that discussed below in the section on multidimensional segments trees), </font></font><a href="http://e-maxx.ru/algo/fenwick_tree"><font><font>Fenwick tree</font></font></a><font><font> , </font></font><a href="http://e-maxx.ru/algo/treap"><font><font>Treap</font></font></a><font><font> etc.</font></font></p><p></p><p></p><a name="20"></a><h3 style="padding-top:15px;" id="header_20"><font><font>Update on the interval</font></font></h3><p><font><font>Above we considered only the problem that affects only a modification request array. </font><font>In fact, the segment tree allows queries that are applied to whole segments of contiguous elements, with these fulfill requests for the same time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>.</font></font></p><p></p><a name="21"></a><h4 id="header_21"><font><font>The addition of the segment</font></font></h4><p><font><font>To begin the consideration of such trees segments with the simplest case: a modification request is adding all the numbers at some subsegments </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font>certain number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>. </font><font>Request for reading - continue reading the value of a number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>.</font></font></p><p><font><font>To make a request of addition effectively will be stored in each node of the tree lines, how much to add to all the numbers of this segment as a whole. </font><font>For example, if the "add to the entire array query comes </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a [0 \ ldots n-1]"><font><font>number 2", we will deliver in the number of tree root </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"><font><font>. </font><font>In this way we will be able to process the request adding any subsegments effectively, rather than to change all </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"><font><font>values.</font></font></p><p><font><font>Now, if a request comes in reading the value of a number, it is sufficient to go down the tree, summing all met on the way values &#8203;&#8203;are stored in the tree tops.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> build <span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> a<span class="br0">[</span>tl<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">)</span><span class="sy4">;</span>
		build <span class="br0">(</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> add<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> r<span class="br0">)</span>
		<span class="kw1">return</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy2">+</span><span class="sy1">=</span> add<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">(</span>r,<span class="kw4">tm</span><span class="br0">)</span>, add<span class="br0">)</span><span class="sy4">;</span>
		update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">(</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, r, add<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> get <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy2">+</span> get <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy2">+</span> get <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p></p><a name="22"></a><h4 id="header_22"><font><font>The assignment of the segment</font></font></h4><p><font><font>Now suppose that the modification request is assigned to all the elements of a certain segment of </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a [l \ ldots r]"><font><font>a certain value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2f8934466bea85c9661745280df23800.png" alt="p"><font><font>. </font><font>The reading will consider values of the array as the second request </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3530c8c1281c8ee618b020a2333a22ca.png" alt="a [i]"><font><font>.</font></font></p><p><font><font>To make a modification to the whole segment, it is necessary at each node of the tree lengths to keep, whether this piece is painted entirely in any number or not (and if painted, the store itself is a number). </font><font>This will allow us to do </font></font><b><font><font>"retarded" Update</font></font></b><font><font> tree segments: upon request modifications we, instead of changing the values in the set of the vertices of segments, changing only some of them, leaving the "colored" flags for the other segments, which means that the entire segment together with its subsegments to be painted in this color.</font></font></p><p><font><font>So, after the modification request becomes a tree segments, generally speaking, irrelevant - there were shortfalls in some modifications.</font></font></p><p><font><font>For example, if the modification request has come, "the entire array to assign </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a [0 \ ldots n-1]"><font><font>a certain number of" segments in the tree we make a single change - label the root of the tree, it is painted entirely in this number. </font><font>The rest of the top of the tree will remain unaltered, but in fact the whole tree should be painted in the same number.</font></font></p><p><font><font>Suppose now that in the same tree segments came second modification request - to paint the first half of the array </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/956cf050b80daaa13a7143f3acb10f4e.png" alt="a [0 \ ldots n / 2]"><font><font>to any other number. </font><font>To handle such a request, we need to paint the entire left child of the root in this new color, but before you do this, we must deal with the root of the tree. </font><font>The subtlety here is that the tree should be preserved, that the right half is colored in the color of old, and at this point in the tree no information to the right half was not saved.</font></font></p><p><font><font>The output is as follows: to make </font></font><b><font><font>the pushing</font></font></b><font><font> of information from the root, ie </font><font>if the root of the tree was painted in any number, then color in the number of its right and left a son, and from the root to remove this mark. </font><font>After that, we can safely paint the left child of the root, without losing any relevant information.</font></font></p><p><font><font>Summing up, we obtain for any queries with a tree (request modification or reading) while descending the tree, we should always do the pushing of information from the current node in both of her sons. </font><font>You can understand it so that when descending the tree we use lagging modification, but only as much as necessary (so as not to worsen with the asymptotic behavior </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>).</font></font></p><p><font><font>When implemented, this means that we need to make a function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/176a4d7539ede6a2826ee87fd28aa331.png" alt="\ Rm push"><font><font>which will be transferred to the top of pieces of wood, and it will make pushing information from this vertex in both her sons. </font><font>Call this function must be at the beginning of request processing functions (but do not call it from the leaves because of the push information sheet is not necessary, and there is no place).</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> push <span class="br0">(</span><span class="kw4">int</span> v<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
		t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="sy4">;</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> color<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> r<span class="br0">)</span>
		<span class="kw1">return</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">)</span>
		t<span class="br0">[</span>v<span class="br0">]</span> <span class="sy1">=</span> color<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		push <span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">(</span>r,<span class="kw4">tm</span><span class="br0">)</span>, color<span class="br0">)</span><span class="sy4">;</span>
		update <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">(</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, r, color<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> get <span class="br0">(</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>v<span class="br0">]</span><span class="sy4">;</span>
	push <span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
		<span class="kw1">return</span> get <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> get <span class="br0">(</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>Function </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/75ab7597c32a38a478cc195daa874346.png" alt="\ Rm get"><font><font>could be implemented in another way: do not do it delayed the update, and immediately return a response as soon as it hits the top of the tree lengths, entirely colored in a particular color.</font></font></p><p></p><a name="23"></a><h4 id="header_23"><font><font>Addition of the segment, the maximum request</font></font></h4><p><font><font>Now suppose that the modification request will again request the addition of all the numbers of a subsegment of the same number, and the read request is to find the maximum in some subsegments.</font></font></p><p><font><font>Then each vertex of the tree segments will have to additionally store a maximum of all this subsegments. </font><font>But subtlety here is how to recalculate these values.</font></font></p><p><font><font>For example, suppose there was a request "added to the entire first half, i.e. </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/956cf050b80daaa13a7143f3acb10f4e.png" alt="a [0 \ ldots n / 2]"><font><font>, number 2". </font><font>Then in the tree it will affect the number of entries </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"><font><font>in the left child of the root. </font><font>How to calculate a new value is now high on the left, and his son at the root? </font><font>Here it becomes important not to get confused - what the maximum is stored in the top of the tree: the maximum without considering adding on top of all this, or considering it. </font><font>You can choose any of these approaches, but the main thing - to consistently use it everywhere. </font><font>For example, when you first approach a maximum at the root will be obtained as a maximum of two numbers: the maximum in the left son, plus the addition of the left son, and the maximum in the right son, plus the addition in it. </font><font>In the second approach is at the root of the maximum will be obtained as the addition of the root plus the maximum of the maxima in the left and right sons.</font></font></p><p></p><a name="24"></a><h4 id="header_24"><font><font>other destinations</font></font></h4><p><font><font>There were considered only the basic application segments trees in problems with modifications in the segment. </font><font>The remaining tasks are obtained based on the same ideas that are described here.</font></font></p><p><font><font>It is only important to be very careful when dealing with pending modifications: it must be remembered that even if the current top we have "pushed" a modification is pending, then the left and right sons, most likely, have not done so. </font><font>So it is often necessary is the cause </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/176a4d7539ede6a2826ee87fd28aa331.png" alt="\ Rm push"><font><font>also of the left and right sons of the current node, or the carefully take into account the pending modifications in them.</font></font></p><p></p><p></p><a name="25"></a><h3 style="padding-top:15px;" id="header_25"><font><font>Generalization to higher dimensions</font></font></h3><p><font><font>Tree sections can be generalized quite naturally on the two-dimensional and multi-dimensional case at all. </font><font>If the one-dimensional case we broke the array indexes into segments, the two-dimensional case is now going first to break all of the first index, and for each segment of the first indices - to build a normal tree segments for the second index. </font><font>Thus, the basic idea of &#8203;&#8203;the solution - it is the insertion of sections of trees on the second index into the wood segments of the first index.</font></font></p><p><font><font>Let us explain this idea by the example of a specific task.</font></font></p><p></p><a name="26"></a><h4 id="header_26"><font><font>The two-dimensional tree segments in the simplest embodiment,</font></font></h4><p><font><font>Dana rectangular matrix </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/6b94972ed8ba79bb3e8e49686ab1e9ec.png" alt="a [0 \ ldots n-1, 0 \ ldots m-1]"><font><font>, and the amount received search requests (or minimum / maximum) at some podpryamougolnikah </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/9899cae2fa585d045f979f7879a339b5.png" alt="a [x_1 \ ldots x_2, y_1 \ ldots y_2]"><font><font>and requests modification of individual matrix elements (i.e., type of requests </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e716b0e93c8fd88c80cdf5c34bc7635a.png" alt="a [x] [y] = p"><font><font>).</font></font></p><p><font><font>So, we will build a two-dimensional tree segments: first wood segments in the first coordinate ( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>), and then - for the second ( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e1fbf2db960f0155bd590871a486e78c.png" alt="y"><font><font>).</font></font></p><p><font><font>To </font></font><b><font><font>construct the process</font></font></b><font><font> more understandable, it is possible to forget that the original array was a two-dimensional, and leave only the first coordinate. </font><font>We will construct the usual one-dimensional tree sections, working only with the first coordinate. </font><font>But as the value of each piece will be written not for a number, as in the one-dimensional case, and the whole tree segments: ie </font><font>at this point we are reminded that we still have, and the second coordinate; </font><font>but because </font><font>at this point is already fixed, the first coordinate is a segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/653023af1da32cf3f51fe321fa0778da.png" alt="[L \ ldots r]"><font><font>, then we are actually working with the band </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/6667265fa55232c5f15f9e7541be3730.png" alt="a [l \ ldots r, 0 \ ldots m-1]"><font><font>, and for her build segment tree.</font></font></p><p><font><font>We present the implementation of operations for constructing a two-dimensional tree. </font><font>It actually consists of two separate units: the construction of the tree segments coordinate </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e3112df90e1fb46809b8f6056d346482.png" alt="\ Rm build \ _x"><font><font>) and the coordinate </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e1fbf2db960f0155bd590871a486e78c.png" alt="y"><font><font>( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4eb2e24d0e09179a13bec9519d32481d.png" alt="\ Rm build \ _y"><font><font>). </font><font>If the first function is almost no different from the usual one-dimensional tree, the latter is forced to deal separately with the two cases: when the current segment of the first coordinate ( </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/3988cf2204e9d8fd5c18e5a01d578a0b.png" alt="[Tlx \ ldots trx]"><font><font>) is unit length, and when - a length greater than one. </font><font>In the first case, we simply take the required value from the matrix </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f9fa957c4ed546b728381d1556189238.png" alt="a [] []"><font><font>, and the second - combine the values of two tree lengths of the left child and right child coordinate </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> build_y <span class="br0">(</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> vy, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>ly <span class="sy1">==</span> ry<span class="br0">)</span>
		<span class="kw1">if</span> <span class="br0">(</span>lx <span class="sy1">==</span> rx<span class="br0">)</span>
			t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy1">=</span> a<span class="br0">[</span>lx<span class="br0">]</span><span class="br0">[</span>ly<span class="br0">]</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy2">+</span> t<span class="br0">[</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> my <span class="sy1">=</span> <span class="br0">(</span>ly <span class="sy2">+</span> ry<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build_y <span class="br0">(</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span>, ly, my<span class="br0">)</span><span class="sy4">;</span>
		build_y <span class="br0">(</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, my<span class="sy2">+</span><span class="nu0">1</span>, ry<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">+</span> t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> build_x <span class="br0">(</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>lx <span class="sy3">!</span><span class="sy1">=</span> rx<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> mx <span class="sy1">=</span> <span class="br0">(</span>lx <span class="sy2">+</span> rx<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build_x <span class="br0">(</span>vx<span class="sy2">*</span><span class="nu0">2</span>, lx, mx<span class="br0">)</span><span class="sy4">;</span>
		build_x <span class="br0">(</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, mx<span class="sy2">+</span><span class="nu0">1</span>, rx<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
	build_y <span class="br0">(</span>vx, lx, rx, <span class="nu0">1</span>, <span class="nu0">0</span>, m<span class="sy2">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>Such a tree segments takes still linear storage capacity, but with a more constant: </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/7df4261488a6ff1c04fccf17800bdd58.png" alt="16 nm"><font><font>the memory cells. </font><font>It is clear that it is built above procedure </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e3112df90e1fb46809b8f6056d346482.png" alt="\ Rm build \ _x"><font><font>is also in linear time.</font></font></p><p><font><font>We now proceed to </font></font><b><font><font>the processing of requests</font></font></b><font><font> . </font><font>To respond to the two-dimensional query will be on the same principle: first, a request to break the first coordinate, and then when we got to the top of some wood pieces in the first coordinate - initiate a request from the relevant sections of the tree on the second coordinate.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">int</span> sum_y <span class="br0">(</span><span class="kw4">int</span> vx, <span class="kw4">int</span> vy, <span class="kw4">int</span> tly, <span class="kw4">int</span> try_, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>ly <span class="sy1">&gt;</span> ry<span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>ly <span class="sy1">==</span> tly <span class="sy3">&amp;&amp;</span> try_ <span class="sy1">==</span> ry<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span><span class="sy4">;</span>
	<span class="kw4">int</span> tmy <span class="sy1">=</span> <span class="br0">(</span>tly <span class="sy2">+</span> try_<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> sum_y <span class="br0">(</span>vx, vy<span class="sy2">*</span><span class="nu0">2</span>, tly, tmy, ly, min<span class="br0">(</span>ry,tmy<span class="br0">)</span><span class="br0">)</span>
		<span class="sy2">+</span> sum_y <span class="br0">(</span>vx, vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, tmy<span class="sy2">+</span><span class="nu0">1</span>, try_, max<span class="br0">(</span>ly,tmy<span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, ry<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> sum_x <span class="br0">(</span><span class="kw4">int</span> vx, <span class="kw4">int</span> tlx, <span class="kw4">int</span> trx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>lx <span class="sy1">&gt;</span> rx<span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>lx <span class="sy1">==</span> tlx <span class="sy3">&amp;&amp;</span> trx <span class="sy1">==</span> rx<span class="br0">)</span>
		<span class="kw1">return</span> sum_y <span class="br0">(</span>vx, <span class="nu0">1</span>, <span class="nu0">0</span>, m<span class="sy2">-</span><span class="nu0">1</span>, ly, ry<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">int</span> tmx <span class="sy1">=</span> <span class="br0">(</span>tlx <span class="sy2">+</span> trx<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> sum_x <span class="br0">(</span>vx<span class="sy2">*</span><span class="nu0">2</span>, tlx, tmx, lx, min<span class="br0">(</span>rx,tmx<span class="br0">)</span>, ly, ry<span class="br0">)</span>
		<span class="sy2">+</span> sum_x <span class="br0">(</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, tmx<span class="sy2">+</span><span class="nu0">1</span>, trx, max<span class="br0">(</span>lx,tmx<span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, rx, ly, ry<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>This function works in the time </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/d74b09d786f708ee7fe805ea61527587.png" alt="O (\ log n \ log m)"><font><font>since it first goes down the tree in the first coordinate, and each traversed the top of the tree - makes a request of a conventional wood pieces on the second coordinate.</font></font></p><p><font><font>Finally, consider a </font></font><b><font><font>modification request</font></font></b><font><font> . </font><font>We want to learn how to modify the segment tree in accordance with the change in the value of any element </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e716b0e93c8fd88c80cdf5c34bc7635a.png" alt="a [x] [y] = p"><font><font>. </font><font>It is clear that changes will occur only in those sections of the first tree tops, which are covered with a coordinate </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"><font><font>(and there is </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>), but for tree segments corresponding to it - the changes will be only in the tops, which are covered with a coordinate </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/e1fbf2db960f0155bd590871a486e78c.png" alt="y"><font><font>(and there is </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/1598b628fc5926ef873e70421a929113.png" alt="O (\ log m)"><font><font>). </font><font>Therefore, the implementation of the modification request will not be much different from the one-dimensional case, but now we will first descend in the first coordinate, and then - for the second.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">void</span> update_y <span class="br0">(</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> vy, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry, <span class="kw4">int</span> x, <span class="kw4">int</span> y, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>ly <span class="sy1">==</span> ry<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>lx <span class="sy1">==</span> rx<span class="br0">)</span>
			t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy1">=</span> new_val<span class="sy4">;</span>
		<span class="kw1">else</span>
			t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy2">+</span> t<span class="br0">[</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span><span class="sy4">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> <span class="br0">{</span>
		<span class="kw4">int</span> my <span class="sy1">=</span> <span class="br0">(</span>ly <span class="sy2">+</span> ry<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>y <span class="sy1">&lt;=</span> my<span class="br0">)</span>
			update_y <span class="br0">(</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span>, ly, my, x, y, new_val<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update_y <span class="br0">(</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, my<span class="sy2">+</span><span class="nu0">1</span>, ry, x, y, new_val<span class="br0">)</span><span class="sy4">;</span>
		t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="br0">]</span> <span class="sy1">=</span> t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy2">+</span> t<span class="br0">[</span>vx<span class="br0">]</span><span class="br0">[</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> update_x <span class="br0">(</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> x, <span class="kw4">int</span> y, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>lx <span class="sy3">!</span><span class="sy1">=</span> rx<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw4">int</span> mx <span class="sy1">=</span> <span class="br0">(</span>lx <span class="sy2">+</span> rx<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>x <span class="sy1">&lt;=</span> mx<span class="br0">)</span>
			update_x <span class="br0">(</span>vx<span class="sy2">*</span><span class="nu0">2</span>, lx, mx, x, y, new_val<span class="br0">)</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update_x <span class="br0">(</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, mx<span class="sy2">+</span><span class="nu0">1</span>, rx, x, y, new_val<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
	update_y <span class="br0">(</span>vx, lx, rx, <span class="nu0">1</span>, <span class="nu0">0</span>, m<span class="sy2">-</span><span class="nu0">1</span>, x, y, new_val<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p></p><a name="27"></a><h4 id="header_27"><font><font>Compression of two-dimensional pieces of wood</font></font></h4><p><font><font>Let the following problem: there are </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"><font><font>points in the plane defined by its coordinates </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/a5be10853e90ed2cd02bc9bf3215a165.png" alt="(X_i, y_i)"><font><font>, and receives requests such as "count the number of points lying in a rectangle </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/dd10350ae2982d2e000611454248ac69.png" alt="((X_1, y_1), (x_2, y_2))"><font><font>." </font><font>It is clear that in the case of such a task becomes unnecessarily wasteful to build a two-dimensional tree lengths from </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n ^ 2)"><font><font>the elements. </font><font>Most of this memory will be wasted, because each single point can be reached only in the </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>segments of the segments in the first coordinate of the tree, and therefore, the total "useful" the size of all the segments of the trees along the second coordinate is the value </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \ log n)"><font><font>.</font></font></p><p><font><font>Then proceed as follows: at each vertex of the tree segments in the first coordinate will store tree sections, built only on the second coordinates, which are found in this segment of the first coordinates. </font><font>In other words, the construction of the tree segments in some vertex with the number </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/968e4d769467a3b751b5ca8d21a356e3.png" alt="vx"><font><font>and boundaries </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/c32e945279af4fef66bfad6836f4deb8.png" alt="tlx, trx"><font><font>, we will consider only those points that fall in this segment </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/77d95cf1d114134382e7c25b638f34dd.png" alt="x \ in [tlx;  trx]"><font><font>, and build a segment tree just above them.</font></font></p><p><font><font>In this way we will achieve that segments each tree along the second coordinate will take exactly as much memory as it should. </font><font>As a result, the total </font></font><b><font><font>amount of memory</font></font></b><font><font> is reduced to </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \ log n)"><font><font>. </font></font><b><font><font>Respond to the request</font></font></b><font><font> , we will continue for </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\ log ^ 2 n)"><font><font>, only now the call request from the wood pieces on the second coordinate, we'll have to do a binary search on the second coordinate, but it does not worsen the asymptotic behavior.</font></font></p><p><font><font>But payback will be impossible to make an arbitrary </font></font><b><font><font>modification request</font></font></b><font><font> : in fact, if a new point, it will lead to the fact that we will have in any tree lengths of the second coordinate to add a new element into the middle of that done effectively impossible.</font></font></p><p><font><font>Finally, we note that in this manner the compressed two-dimensional tree segments is practically </font></font><b><font><font>equivalent to</font></font></b><font><font> the above modification segments dimensional tree (cm. "Preservation of all subarray in each node of the tree segments"). </font><font>In particular, it turns out that a two-dimensional tree described here segments - this is just a special case of the conservation of the subarray in each node of the tree, where he subarray is stored in the form of pieces of wood. </font><font>It follows that if you have to abandon the two-dimensional pieces of wood because of the impossibility of any given request, it makes sense to try to replace the embedded segment tree to any more powerful data structure, such as </font></font><a href="http://e-maxx.ru/algo/treap"><font><font>a Cartesian tree</font></font></a><font><font> .</font></font></p><p></p><p></p><a name="28"></a><h3 style="padding-top:15px;" id="header_28"><font><font>Wood preserving segments of its history values &#8203;&#8203;(data to improve persistent-structure)</font></font></h3><p><font><font class="">Persistent-structure data called a data structure such that, when each modification remembers its previous state. </font><font>This allows, if necessary, appeal to any interest to us, this version of the data structure and perform a query on it.</font></font></p><p><font><font>Wood is one of the segments of the data structures that can be turned into a persistent-data structure (of course, we see persistent-effective structure, and not one that copies all himself entirely before each update).</font></font></p><p><font><font>In fact, any request for changes to the tree segments leads to a change in data in </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>the tops, with along the way, starting from the root. </font><font>So if we keep the tree lengths on signs (ie, pointers to the left and right to make the sons of pointers stored in the top), then the update request, we just have to change instead of having a vertex to create new vertices, links of which are directed to the old tops. </font><font>Thus, when requesting an update will be created </font></font><img class="tex" src="./MAXimal __ algo __ Tree segments_files/f164aa195cc12acf4e3719819f08c698.png" alt="O (\ log n)"><font><font>new heights, including a new tree root segments and all prev version tree hanging over the old root is created, will remain unchanged.</font></font></p><p><font><font>Here is an example implementation of the simplest pieces of wood when there is only a request to the calculation of the amount of subsegments and modification request singular.</font></font></p><p></p><pre class="notranslate cpp"><span class="kw4">struct</span> vertex <span class="br0">{</span>
	vertex <span class="sy2">*</span> l, <span class="sy2">*</span> r<span class="sy4">;</span>
	<span class="kw4">int</span> sum<span class="sy4">;</span>
&nbsp;
	vertex <span class="br0">(</span><span class="kw4">int</span> val<span class="br0">)</span>
		<span class="sy4">:</span> l<span class="br0">(</span><span class="kw2">NULL</span><span class="br0">)</span>, r<span class="br0">(</span><span class="kw2">NULL</span><span class="br0">)</span>, sum<span class="br0">(</span>val<span class="br0">)</span>
	<span class="br0">{</span> <span class="br0">}</span>
&nbsp;
	vertex <span class="br0">(</span>vertex <span class="sy2">*</span> l, vertex <span class="sy2">*</span> r<span class="br0">)</span>
		<span class="sy4">:</span> l<span class="br0">(</span>l<span class="br0">)</span>, r<span class="br0">(</span>r<span class="br0">)</span>, sum<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>l<span class="br0">)</span>  sum <span class="sy2">+</span><span class="sy1">=</span> l<span class="sy2">-</span><span class="sy1">&gt;</span>sum<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>r<span class="br0">)</span>  sum <span class="sy2">+</span><span class="sy1">=</span> r<span class="sy2">-</span><span class="sy1">&gt;</span>sum<span class="sy4">;</span>
	<span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
vertex <span class="sy2">*</span> build <span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">(</span>a<span class="br0">[</span>tl<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">(</span>
		build <span class="br0">(</span>a, tl, <span class="kw4">tm</span><span class="br0">)</span>,
		build <span class="br0">(</span>a, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">)</span>
	<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> get_sum <span class="br0">(</span>vertex <span class="sy2">*</span> t, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">&gt;</span> r<span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">)</span>
		<span class="kw1">return</span> t<span class="sy2">-</span><span class="sy1">&gt;</span>sum<span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> get_sum <span class="br0">(</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>l, tl, <span class="kw4">tm</span>, l, min<span class="br0">(</span>r,<span class="kw4">tm</span><span class="br0">)</span><span class="br0">)</span>
		<span class="sy2">+</span> get_sum <span class="br0">(</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>r, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">(</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">)</span>, r<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
vertex <span class="sy2">*</span> update <span class="br0">(</span>vertex <span class="sy2">*</span> t, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">)</span> <span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>tl <span class="sy1">==</span> tr<span class="br0">)</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">(</span>new_val<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">(</span>tl <span class="sy2">+</span> tr<span class="br0">)</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">(</span>
				update <span class="br0">(</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>l, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">)</span>,
				t<span class="sy2">-</span><span class="sy1">&gt;</span>r
			<span class="br0">)</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">(</span>
				t<span class="sy2">-</span><span class="sy1">&gt;</span>l,
				update <span class="br0">(</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>r, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">)</span>
			<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p><font><font>With this approach it is possible to turn into a persistent-data structure of almost any segment tree.</font></font></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
</p><div id="disqus_thread"><iframe id="dsq-app1" name="dsq-app1" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./MAXimal __ algo __ Tree segments_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 6849px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></tbody></table><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe style="display: none;" src="./MAXimal __ algo __ Tree segments_files/saved_resource(2).html"></iframe></body></html>